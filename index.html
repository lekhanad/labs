<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>
        <div>
            <h2>            part A            </h2>
            <h4>Question 1</h4>
            <p>Design and analyze a divide and conquer algorithm for following maximum subarray sum problem, given an array of integers find a sub-array [a contagious portion of the array] which gives the maximum sum
            </p>
            <p><pre>
                #include <stdio.h>
    #include <limits.h>

    int max1(int a, int b) 
    { 
	return (a > b)? a : b; 
}

int max2(int a, int b, int c) 
{ 
	return max1(max1(a, b), c); 
}

int maxCrossingSum(int arr[], int l, int m, int h)
{
	int sum = 0;
	int left_sum = INT_MIN;
	for (int i = m; i >= l; i--)
	{
		sum = sum + arr[i];
		if (sum > left_sum)
		left_sum = sum;
}
	sum = 0;
	int right_sum = INT_MIN;
	for (int i = m+1; i <= h; i++)
	{
sum = sum + arr[i];
if (sum > right_sum)
right_sum = sum;
}
return left_sum + right_sum;
}
int maxSubArraySum(int arr[], int l, int h)
{
	if (l == h)
	return arr[l];

	int m = (l + h)/2;

	return max2(maxSubArraySum(arr, l, m), maxSubArraySum(arr, m+1, h), maxCrossingSum(arr, l, m, h));

}

int main()
{
	int arr[20],n,i;
	printf("enter the number of elements\n");
	scanf("%d",&n);
	printf("enter the elements\n");
	for(i=0;i< n;i++)
	scanf("%d",&arr[i]);
	int max_sum = maxSubArraySum(arr, 0, n-1);
	printf("Maximum contiguous sum is %d\n", max_sum);
getchar();
	return 0;
}
output:enter the number of elements
4
enter the elements
1 -2 -2 4
Maximum contiguous sum is 4

                </pre>
            </p>
<h4>Question 2</h4>
<p>
    <p>QuickSort</p>
    <pre>
void quicksort(int a[50],int f, int l)
{
int i, j, pivot, t;
if(f< l)
{
    pivot=f;
    i=f;
    j=l;
    while(i< j)
    {
        while (a[i] < = a[pivot] && i< j)
         i++;
        while(a[j]>a[pivot])
         j--;
        if(i< j)
        {
t=a[i];
a[i]=a[j];
a[j]=t;
        }
        t=a[pivot];
        a[pivot]=a[j];
        a[j]=t;
    quicksort(a,f,j-1);
    quicksort(a,j+1,l);
    }
}
}
int main()
{	
int i,a[100];
time_t t;
srand((unsigned) time(&t));
for(i=0;i< max;i++)
a[i]=rand()%100;
quicksort(a,0,max-1);
for(i=0;i< max;i++)
printf("%d\t",a[i]);
} 
        
        
        Output:
        37      45      46      48      64      65      75      91      93      95
        
    </pre>
</p>
            <h4>Question 3</h4>
            <p>matric chain</p>
            <p><pre>
#include <stdio.h>
#include <limits.h>
    
int matchain(int p[], int n)
{
  int m[n][n];
int i,j,k,l,q;
for (i=1;i< n;i++)
    m[i][i]=0;
    for(l=2;l< n;l++)
    {
        for(i=1;i< n-l+1; i++)
        {
            j=i+l-1;
            m[i][j]=INT_MAX;
            for(k=i;k<=j-1;k++)
            {
                q=m[i][k]+m[k+1][j]+p[i-1] *p[k]*p[j];
                if(q< m[i][j])
                    m[i][j]=q;
            }
        }
    }
return m[1][n-1];
}
                    
int main(){
int arr[]={5,4,6,2,7};
int size= sizeof(arr)/ sizeof(arr[0]);
printf("min of the multiplication is %d", matchain(arr,size));
getchar();
return 0;
}
                    
                    Output:
                    min of the multiplication is 158
                    
            </pre></p>
            <h4>Question 4</h4>
            <p>lcs</p>            
            <p><pre>
int max(int a , int b){
    if(a>b) return a;
    return b;
}

void lcs(char*x, char* y, int m, int n)
{
    int i, index, j;
    int l[m+1][n+1];
    for(i=0; i<=m; i++)
    {
    for(j=0; j<=n; j++)
        {
            if(i==0 || j==0)
              l[i][j]=0;
            else if( x[i-1] == y[j-1])
              l[i][j] = l[i-1][j-1] + 1;
            else
              l[i][j] = max(l[i-1][j],l[i][j-1]);
        }
    }
    index=l[m][n];
    char lcs[index+1];
    lcs[index] ='\0';
    i=m; j=n;
    while(i>0 && j>0)
    {
        if(x[i-1]==y[j-1])
        {
            lcs[index-1] =x[i-1];
            i--;
            j--;
            index--;
        }
        else if(l[i-1][j]> l[i][j-1])
            i--;
        else
            j--;
    }
    printf("lcs of %s and %s is : %s", x,y,lcs);
}

int main()
{
    int m, n;
    char x[20],y[20];
    printf("Enter string 1 : ");
    gets(x);
    printf("Enter the string 2 : ");
    gets(y);
    m=strlen(x);
    n= strlen(y);
    lcs(x,y,m,n);
    return 0;
}

output:Enter string 1 : a b c dEnter the string 2 : a e c b dlcs of a b c d and a e c b d is : a  c d
            </pre></p>
            <h4>Question 5</h4>
            <p>knapsack</p>
            <p><pre>
#include <stdio.h>
 
    int max(int a, int b) { return (a > b) ? a : b; }
     
    int knapSack(int W, int wt[], int val[], int n)
    {
        int i, w;
        int K[n + 1][W + 1];
     
        for (i = 0; i <= n; i++) {
            for (w = 0; w <= W; w++) {
              if (i == 0 || w == 0)
                  K[i][w] = 0;
              else if (wt[i - 1] <= w)
                K[i][w] = max(val[i - 1]+ K[i - 1][w - wt[i - 1]], K[i - 1][w]);
              else
                K[i][w] = K[i - 1][w];
            }
        }
     
        return K[n][W];
    }
    
    int main()
    {
        int profit[] = { 2,3,1,4 };
        int weight[] = { 3,4,6,5 };
        int W = 8;
        int n = sizeof(profit) / sizeof(profit[0]);
        printf("%d", knapSack(W, weight, profit, n));
        return 0;
    }
    
    Output:  
6
                    
            </pre></p>
            <h4>Question 6</h4>
            <p>TSP</p>
            <p><pre>
#include<stdio.h>
int a[10][10],n,visit[10];
int cost_opt=0,cost_apr=0;
int least_apr(int c);
int least_opt(int c);

void mincost_opt(int city)
{
int ncity;
visit[city]=1;
printf("%d-->",city);
ncity=least_opt(city);
if(ncity==999)
  {
    ncity=1;
    printf("%d",ncity);
    cost_opt+=a[city][ncity];
    return;
  }
  mincost_opt(ncity);
  }
            
  
int least_opt(int c)
{
int i,nc=999;
int min=999,kmin=999;
for(i=1;i< =n;i++)
{
  if((a[c][i]!=0)&&(visit[i]==0))
  if(a[c][i]< min)
{
  min=a[i][1]+a[c][i];
  kmin=a[c][i];
  nc=i;
  }
}
if(min!=999)
  cost_opt+=kmin;
return nc;
}


int main()
{
  int i,j;
  printf("Enter No. of cities:\n");
  scanf("%d",&n);
  printf("Enter the cost matrix\n");
  for(i=1;i<=n;i++)
  {
    printf("Enter elements of row:%d\n",i );
    for(j=1;j<=n;j++)
    scanf("%d",&a[i][j]);
    visit[i]=0;
  }

  printf("\n\n Optimal Solution :\n");
  mincost_opt(1);
  printf(" \nMinimum cost %d",cost_opt);

  printf("\n\n Approximated Solution :\n");
  for(i=1;i<=n;i++)
    visit[i]=0;
  mincost_apr(1);
  printf("\nMinimum cost: %d",cost_apr);
  printf("\n\nError in approximation is approximated solution/optimal solution=%f",
    (float)cost_apr/cost_opt);
}
            
Output:

Enter No. of cities:
4
Enter the cost matrix
Enter elements of row:1
0 1 3 6
Enter elements of row:2
1 0 2 3
Enter elements of row:3
3 2 0 1
Enter elements of row:4
6 3 1 0
The cost list is
        0       1       3       6

        1       0       2       3

        3       2       0       1

        6       3       1       0
Optimal Solution :

 The path is :
1-->2-->4-->3-->1
 Minimum cost:8

 Approximated Solution :

  The path is :
1-->2-->3-->4-->1
Minimum cost:10
error =1.25000
</pre></p>
<h4>activity selection</h4>
<p><pre>
    #include<stdio.h>
                    
int main() 
{
  int start[] = {1, 3, 2, 0, 5, 8, 11};
  int finish[] = {3, 4, 5, 7, 9, 10, 12};
  int n = sizeof(start) / sizeof(start[0]);
   printf("The following activities are selected:\n");
  int j = 0;
  printf("%d ", j);
  int i;
  for (i = 1; i < n; i++)
  {
    if (start[i] >= finish[j])
    {
      printf("%d ", i);
      j = i;
    }
  }
  return 0;
}


Output:

The following activities are selected:
0 1 4 6

            </pre></p>
            <h4>multithread merge_sort</h4>
          
            <p><pre>

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
 
#define MAX_SIZE 100
 
int arr[MAX_SIZE];
int temp[MAX_SIZE];
 
void merge(int left, int mid, int right) {
   int i, j, k;
   for (i = left, j = mid + 1, k = left; i <= mid && j <= right; k++) {
       if (arr[i] <= arr[j])
           temp[k] = arr[i++];
       else
           temp[k] = arr[j++];
   }
   while (i <= mid)
       temp[k++] = arr[i++];
   while (j <= right)
       temp[k++] = arr[j++];
   for (i = left; i <= right; i++)
       arr[i] = temp[i];
}
 
void* merge_sort(void* arg) {
   int* args = (int*)arg;
   int left = args[0];
   int right = args[1];
   if (left < right) {
       int mid = (left + right) / 2;
       int args1[2] = {left, mid};
       int args2[2] = {mid + 1, right};
       pthread_t tid1, tid2;
       pthread_create(&tid1, NULL, merge_sort, args1);
       pthread_create(&tid2, NULL, merge_sort, args2);
       pthread_join(tid1, NULL);
       pthread_join(tid2, NULL);
       merge(left, mid, right);
   }
   pthread_exit(NULL);
}
 
int main() {
   int n, i;
   printf("Enter the number of elements: ");
   scanf("%d", &n);
   printf("Enter the elements:\n");
   for (i = 0; i < n; i++)
       scanf("%d", &arr[i]);
 
   int args[2] = {0, n - 1};
   pthread_t tid;
   pthread_create(&tid, NULL, merge_sort, args);
   pthread_join(tid, NULL);
 
   printf("Sorted array:\n");
   for (i = 0; i < n; i++)
       printf("%d ", arr[i]);
   printf("\n");
 
   return 0;
}

output:-Enter the number of elements: 8
Enter the elements:51347268 
Sorted array:1 2 3 4 5 6 7 8
                    
            </pre></p>
            <h4>naive string </h4>
            <p><pre>

#include <stdio.h>
#include <conio.h>
#include <string.h>
int main()
{
int i,j;
char txt[] ="a b c d q a b b c x y z p q";
char pat[] ="a b b c";
int n =strlen(txt);
int m =strlen(pat);
for( i=0;i< n -m ;i++)
{
for( j=0; j< m ; j++)
if(txt[i+j]!= pat[j])
break;
if(j==m)
printf("match found in %d",i);
}
return 0;
}
    
    output:match found in 10
            </pre></p>

 <h4>kmp </h4>
 <p>
 </p>
 <p>
 <pre>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
void KMP(const char* text, const char* pattern, int m, int n)
{
if (*pattern == '\0' || n == 0) {
  printf("The pattern found at index 0");
}
 
if (*text == '\0' || n > m) {
  printf("Pattern not found");
}
 
int next[n + 1];
 
for (int i = 0; i < n + 1; i++) {
  next[i] = 0;
}
 
for (int i = 1; i < n; i++)
{
int j = next[i];
 
while (j > 0 && pattern[j] != pattern[i]) {
  j = next[j];
}
 
if (j > 0 || pattern[j] == pattern[i]) {
  next[i + 1] = j + 1;
}
}
 
for (int i = 0, j = 0; i < m; i++)
{
  if (*(text + i) == *(pattern + j))
  {
    if (++j == n) {
    printf("The pattern found at index %d\n", i - j + 1);
    }
  }
else if (j > 0)
  {
    j = next[j];
    i--;
  }
  }
}
 
int main(void)
{
char* text = "ABCABAABCABAC";
char* pattern = "CAB";
 
int n = strlen(text);
int m = strlen(pattern);
 
KMP(text, pattern, n, m);
 
return 0;
}

output:

The pattern found at index 2
The pattern found at index 8
                                        
            </pre></p>
   <h4>job sequence </h4>
            
            <p><pre>
#include <stdio.h>
    #define MAX 100
    
    typedef struct Job {
      char id[5];
      int deadline;
      int profit;
    } Job;
    
    void jobSequencingWithDeadline(Job jobs[], int n);
    
    int minValue(int x, int y) {
      if(x < y) return x;
      return y;
    }
    
    int main(void) {
      //variables
      int i, j;
    
      //jobs with deadline and profit
      Job jobs[5] = {
        {"j1", 2, 40},
        {"j2", 1, 50},
        {"j3", 3, 10},
        {"j4", 2, 30},
        {"j5", 1, 20},
      };
    
      //temp
      Job temp;
    
      //number of jobs
      int n = 5;
    
      //sort the jobs profit wise in descending order
      for(i = 1; i < n; i++) {
        for(j = 0; j < n - i; j++) {
          if(jobs[j+1].profit > jobs[j].profit) {
            temp = jobs[j+1];
            jobs[j+1] = jobs[j];
            jobs[j] = temp;
          }
        }
      }
    
      printf("%10s %10s %10s\n", "Job", "Deadline", "Profit");
      for(i = 0; i < n; i++) {
        printf("%10s %10i %10i\n", jobs[i].id, jobs[i].deadline, jobs[i].profit);
      }
    
      jobSequencingWithDeadline(jobs, n);
    
      return 0;
    }
    
    void jobSequencingWithDeadline(Job jobs[], int n) {
      //variables
      int i,j,k,maxprofit;
    
      //free time slots
      int timeslot[MAX];
    
      //filled time slots
      int filledTimeSlot = 0;
    
      //find max deadline value
      int dmax = 0;
      for(i = 0; i < n; i++) {
        if(jobs[i].deadline > dmax) {
          dmax = jobs[i].deadline;
        }
      }
    
      //free time slots initially set to -1 [-1 denotes EMPTY]
      for(i = 1; i <= dmax; i++) {
        timeslot[i] = -1;
      }
    
      printf("dmax: %d\n", dmax);
    
      for(i = 1; i <= n; i++) {
        k = minValue(dmax, jobs[i - 1].deadline);
        while(k >= 1) {
          if(timeslot[k] == -1) {
            timeslot[k] = i-1;
            filledTimeSlot++;
            break;
          }
          k--;
        }
    
        //if all time slots are filled then stop
        if(filledTimeSlot == dmax) {
          break;
        }
      }
    
      //required jobs
      printf("\nRequired Jobs: ");
      for(i = 1; i <= dmax; i++) {
        printf("%s", jobs[timeslot[i]].id);
    
        if(i < dmax) {
          printf(" --> ");
        }
      }
    
      //required profit
      maxprofit = 0;
      for(i = 1; i <= dmax; i++) {
        maxprofit += jobs[timeslot[i]].profit;
      }
      printf("\nMax Profit: %d\n", maxprofit);
    }
    
    
    Output:
          Job   Deadline     Profit
            j2          1         50
            j1          2         40
            j4          2         30
            j5          1         20
            j3          3         10
    dmax: 3
    
    Required Jobs: j2 --> j1 --> j3
    Max Profit: 100
    
            </pre></p>
            <h4>b-tree 9</h4>
          
            <p><pre>
#include <stdio.h>
    #include <stdlib.h>
    
    #define MAX 3
    #define MIN 2
    
    struct BTreeNode {
      int val[MAX + 1], count;
      struct BTreeNode *link[MAX + 1];
    };
    
    struct BTreeNode *root;
    
    // Create a node
    struct BTreeNode *createNode(int val, struct BTreeNode *child) {
      struct BTreeNode *newNode;
      newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));
      newNode->val[1] = val;
      newNode->count = 1;
      newNode->link[0] = root;
      newNode->link[1] = child;
      return newNode;
    }
    
    // Insert node
    void insertNode(int val, int pos, struct BTreeNode *node,struct BTreeNode *child) 
    {
      int j = node->count;
      while (j > pos) {
        node->val[j + 1] = node->val[j];
        node->link[j + 1] = node->link[j];
        j--;
      }
      node->val[j + 1] = val;
      node->link[j + 1] = child;
      node->count++;
    }
    
    // Split node
    void splitNode(int val, int *pval, int pos, struct BTreeNode *node,
             struct BTreeNode *child, struct BTreeNode **newNode) {
      int median, j;
    
      if (pos > MIN)
        median = MIN + 1;
      else
        median = MIN;
    
      *newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));
      j = median + 1;
      while (j <= MAX) {
        (*newNode)->val[j - median] = node->val[j];
        (*newNode)->link[j - median] = node->link[j];
        j++;
      }
      node->count = median;
      (*newNode)->count = MAX - median;
    
      if (pos <= MIN) {
        insertNode(val, pos, node, child);
      } else {
        insertNode(val, pos - median, *newNode, child);
      }
      *pval = node->val[node->count];
      (*newNode)->link[0] = node->link[node->count];
      node->count--;
    }
    
    // Set the value
    int setValue(int val, int *pval,struct BTreeNode *node, struct BTreeNode **child) {
      int pos;
      if (!node) {
        *pval = val;
        *child = NULL;
        return 1;
      }
    
      if (val < node->val[1]) {
        pos = 0;
      } else {
        for (pos = node->count;
           (val < node->val[pos] && pos > 1); pos--)
          ;
        if (val == node->val[pos]) {
          printf("Duplicates are not permitted\n");
          return 0;
        }
      }
      if (setValue(val, pval, node->link[pos], child)) {
        if (node->count < MAX) {
          insertNode(*pval, pos, node, *child);
        } else {
          splitNode(*pval, pval, pos, node, *child, child);
          return 1;
        }
      }
      return 0;
    }
    
    // Insert the value
    void insert(int val) {
      int flag, i;
      struct BTreeNode *child;
    
      flag = setValue(val, &i, root, &child);
      if (flag)
        root = createNode(i, child);
    }
    
    // Search node
    void search(int val, int *pos, struct BTreeNode *myNode) {
      if (!myNode) {
        return;
      }
    
      if (val < myNode->val[1]) {
        *pos = 0;
      } else {
        for (*pos = myNode->count;
           (val < myNode->val[*pos] && *pos > 1); (*pos)--)
          ;
        if (val == myNode->val[*pos]) {
          printf("%d is found", val);
          return;
        }
    else
          printf("%d is not found", val);
      }
      search(val, pos, myNode->link[*pos]);
    
      return;
    }
    
    // Traverse then nodes
    void traversal(struct BTreeNode *myNode) {
      int i;
      if (myNode) {
        for (i = 0; i < myNode->count; i++) {
          traversal(myNode->link[i]);
          printf("%d ", myNode->val[i + 1]);
        }
        traversal(myNode->link[i]);
      }
    }
    
    int main() {
      int  ch;
    
      insert(10);
      insert(34);
      insert(78);
      insert(45);
      insert(123);
      insert(341);
      insert(234);
      insert(167);
      insert(159);
      insert(52);
        insert(83);
    
      traversal(root);
    
      printf("\n");
      search(99, &ch, root);
    }
    
    
    Output:
    10 34 45 52 78 83 123 159 167 234 341
    99 is not found
    
            </pre></p>


        </div>
</div>
</body> 
</html> 
